"use client";

import React, { useMemo, useState, useEffect } from "react";
import { Search, BookOpen, ChevronRight, Sun, Moon } from "lucide-react";
import CodeBlock from "@/components/CodeBlock";
import Link from "next/link"; // ← 在文件最上方加上这个
import Image from "next/image";


/** ---------- 内容数据类型 ---------- */
type PNode = { type: "p"; text: string };
type CodeNode = { type: "code"; code: string; lang?: string; filename?: string };
type ListNode = { type: "ul"; items: string[] };

/** ✅ 新增：图片节点 */
type ImgNode = {
  type: "img";
  src: string;         // 例如: "/images/system-collaboration-webit.png"
  alt: string;         // 无障碍/SEO
  caption?: string;    // 说明文字（可选）
  width?: number;      // 用 next/image 时推荐
  height?: number;     // 用 next/image 时推荐
};
/** ---------- 内容数据类型 ---------- */
type ContentNode = PNode | CodeNode | ListNode | ImgNode;

type Lesson = {
  id: string;
  title: string;
  summary?: string;
  content: ContentNode[];
  level?: "basic" | "intermediate" | "advanced";
  estMin?: number;
};

type Chapter = {
  key: string;
  title: string;
  lessons: Lesson[];
};

/** ---------- 示例课程大纲 ---------- */
const CURRICULUM: Chapter[] = [
  {
    "key": "requirements-definition",
    "title": "要件定義",
    "lessons": [
      {
        "id": "what-is-requirements-definition",
        "title": "要件定義とは何か",
        "summary": "システム開発の最初の工程であり、「どんなシステムを作るのか」をお客様と一緒に決めるプロセスです。",
        "content": [
          {
            "type": "p",
            "text": "要件定義は、システム開発の上流工程の中でも特に重要なステップで、「どんな課題を、どのようなシステムで解決するのか」を明確にするプロセスです。ここで決まった内容をもとに、基本設計・詳細設計・開発といった後工程が進んでいきます。"
          },
          {
            "type": "p",
            "text": "お客様は「こんなことがしたい」というふわっとした要望を持っていることが多く、SEはその要望をヒアリングしながら、業務フローや画面イメージ、必要なデータ、他システムとの連携などを整理し、誰が見ても分かる形のドキュメント（要件定義書）に落とし込みます。"
          },
          {
            "type": "ul",
            "items": [
              "システム開発の「スタート地点」を決める工程",
              "お客様の要望を、実現可能な「要件」に変換する作業",
              "この工程の曖昧さ・漏れが、後工程のトラブルの原因になりやすい"
            ]
          }
        ]
      },
      {
        "id": "hearing-and-as-is-analysis",
        "title": "業務ヒアリングと現状（As-Is）の整理",
        "summary": "現状の業務フローや課題を正しく理解することが、良い要件定義の出発点になります。",
        "content": [
          {
            "type": "p",
            "text": "要件定義の初期フェーズでは、まず「今どのように仕事をしているのか（As-Is）」を正しく理解することから始まります。ここでの理解が浅いと、本当に解決すべき課題を見落としたり、実際の現場と合わないシステムを設計してしまう危険があります。"
          },
          {
            "type": "p",
            "text": "SEは現場担当者やマネージャーへのヒアリング、既存システムや帳票の確認などを通じて、業務の流れや入力・出力情報、手作業で行っている部分、ボトルネックになっている部分を洗い出していきます。"
          },
          {
            "type": "ul",
            "items": [
              "現場担当者へのインタビューで、日々の具体的な業務手順を確認する",
              "既存システムの画面・帳票・マニュアルを収集し、情報の流れを可視化する",
              "業務フロー図（業務フローチャート）として、As-Isのプロセスを整理する",
              "どこに無駄があり、どこでミスが起きやすいかといった「課題ポイント」をまとめる"
            ]
          }
        ]
      },
      {
        "id": "to-be-and-scope-definition",
        "title": "To-Be像の設計とスコープ定義",
        "summary": "「あるべき姿（To-Be）」と「今回どこまでやるか（スコープ）」を決めることで、プロジェクトのゴールが明確になります。",
        "content": [
          {
            "type": "p",
            "text": "As-Isを整理したあとは、「今後どのような業務フロー・システムにしたいのか」というTo-Be像をお客様と一緒に描いていきます。この段階では、単に現状をシステム化するだけでなく、業務の無駄を減らしたり、作業を標準化したりする視点も重要です。"
          },
          {
            "type": "p",
            "text": "同時に、「今回の開発ではどこまでを対象とし、どこから先は対象外にするのか」という範囲（スコープ）を決めることも不可欠です。スコープが曖昧なままだと、後から「これも対応してほしい」と機能追加の要望が膨らみ、納期・コスト・品質のすべてが崩れる原因になります。"
          },
          {
            "type": "ul",
            "items": [
              "To-Be業務フロー図を作成し、業務の流れがどう変わるかを整理する",
              "対象となる部門・ユーザー・業務プロセスを明確にする",
              "今回対応するシステム連携／対応しないシステム連携を整理する",
              "「必須要件」と「余裕があれば対応する要件（ウォンツ）」を区別しておく"
            ]
          }
        ]
      },
      {
        "id": "functional-and-nonfunctional",
        "title": "機能要件と非機能要件の整理",
        "summary": "「何ができるシステムか」と「どのように動くシステムか」を分けて定義するのがポイントです。",
        "content": [
          {
            "type": "p",
            "text": "要件定義では、システムに求められる内容を大きく「機能要件」と「非機能要件」に分けて整理します。機能要件は「何ができるシステムか」、非機能要件は「どのように動くシステムか」を表すものだとイメージすると分かりやすくなります。"
          },
          {
            "type": "p",
            "text": "機能要件は、画面・帳票・バッチ処理・外部連携など、ユーザーが行いたい操作や手続きに対応する具体的な機能の一覧です。一方、非機能要件は、性能（レスポンス時間、同時接続数）、セキュリティ（認証・権限）、可用性（稼働時間）、保守性、拡張性など、システムとしての“品質”に関わる条件を表します。"
          },
          {
            "type": "ul",
            "items": [
              "機能要件の例：受注登録、在庫引当、請求書発行、CSV取込、他システムへのデータ連携",
              "非機能要件の例：画面レスポンスは3秒以内、24時間365日稼働、障害時は15分以内に復旧開始",
              "セキュリティ要件：ログイン認証、アクセス権限、監査ログの保存期間 など",
              "運用・保守要件：バックアップ方式、障害連絡フロー、運用担当者の作業手順"
            ]
          }
        ]
      },
      {
        "id": "requirements-document-and-communication",
        "title": "要件定義書と合意形成・失敗パターン",
        "summary": "要件定義書は「契約書」に近い重みを持つ文書であり、合意形成とコミュニケーションが成功の鍵となります。",
        "content": [
          {
            "type": "p",
            "text": "要件定義の結果は、通常「要件定義書」として文書化されます。要件定義書は、システムが満たすべき条件を一覧にしたものであり、開発会社とお客様の間で共有される“共通認識の基準”となります。見積や契約、基本設計以降の工程は、この要件定義書を前提として進められます。"
          },
          {
            "type": "p",
            "text": "SEにとって重要なのは、ただドキュメントを作るだけではなく、お客様と何度もレビューを行い、「この内容で本当に問題ないか」「抜け漏れや誤解はないか」を確認し、最終的に合意を得ることです。ここでのコミュニケーションが不十分だと、後から『そんなつもりではなかった』というトラブルにつながります。"
          },
          {
            "type": "ul",
            "items": [
              "要件定義書には、業務フロー、機能一覧、画面・帳票の概要、非機能要件、対象範囲などを整理して記載する",
              "レビュー会を通じて、お客様と開発側の認識のズレを早期に発見・修正する",
              "曖昧な表現（「適宜」「できるだけ早く」など）を避け、測定可能な基準で記載する",
              "要件定義の典型的な失敗パターン：スコープが曖昧、現場の声を聞いていない、非機能要件が後回し など"
            ]
          },
          {
            "type": "p",
            "text": "就活の面接では、『要件定義の重要性は何だと思いますか？』『上流工程で心掛けたいことは？』といった質問がよく出ます。その際には、単に工程名を暗記するのではなく、「お客様との認識合わせ」「後工程の手戻りを防ぐ」「業務理解がベースになる」といった観点で、自分の言葉で説明できると好印象です。"
          }
        ]
      }
    ]
  },
  {
    "key": "basic-design",
    "title": "基本設計",
    "lessons": [
      {
        "id": "what-is-basic-design",
        "title": "基本設計とは何か",
        "summary": "要件定義で決めた内容を「システムとしてどのように実現するか」を設計する工程です。",
        "content": [
          {
            "type": "p",
            "text": "基本設計（外部設計）は、要件定義で決めた内容をもとに、システム全体の構造や画面、データの流れ、外部システムとの連携方法などを設計する工程です。ユーザーが直接触れる部分の仕様を決めるため、「ユーザー視点の設計」とも呼ばれます。"
          },
          {
            "type": "p",
            "text": "この工程では、実際のプログラム内部の処理方法までは踏み込まず、『どの画面で何ができるのか』『どのデータをどのように扱うのか』といった外部仕様を中心に設計していきます。"
          },
          {
            "type": "ul",
            "items": [
              "画面や帳票の仕様を決める",
              "業務フローに沿ったデータの流れを設計する",
              "外部システムとの連携方式（API/ファイル連携）を定義する",
              "非機能要件をシステム全体の構造に落とし込む"
            ]
          }
        ]
      },
      {
        "id": "screen-design",
        "title": "画面設計（UI/UX設計）",
        "summary": "ユーザーが実際に利用する画面の項目・操作手順・遷移を具体化する作業です。",
        "content": [
          {
            "type": "p",
            "text": "画面設計では、ユーザーがどのように画面を操作し、どの項目を入力し、どのボタンを押すのかといった具体的な UI/UX の流れを決めます。要件定義で決めた機能を“実際の操作”の形に落とし込む工程です。"
          },
          {
            "type": "ul",
            "items": [
              "画面遷移図（どの画面からどの画面へ移動できるか）",
              "ワイヤーフレーム（簡易画面レイアウト）",
              "入力項目一覧（項目名・型・入力制御・バリデーション）",
              "エラーメッセージ仕様（どんな場合に、どのメッセージを出すか）"
            ]
          },
          {
            "type": "p",
            "text": "業務システム特有のポイントとして、『入力チェックの厳しさ』と『操作ミスの防止』があります。日本企業向けのシステムでは、入力漏れ・誤入力を徹底的に防ぐ仕様が求められる場合が多いです。"
          }
        ]
      },
      {
        "id": "data-design",
        "title": "データ設計（テーブル・項目・関連）",
        "summary": "業務で扱う情報を、どのようなデータ構造で管理するかを決める工程です。",
        "content": [
          {
            "type": "p",
            "text": "データ設計では、要件定義で整理した業務データ（注文、顧客、在庫など）を、システム内でどのように管理するかを決めます。基本設計では、テーブル構造をすべて確定するのではなく、主にデータ項目やデータ間の関連性を設計します。"
          },
          {
            "type": "ul",
            "items": [
              "エンティティ一覧（どんなデータを扱うか）",
              "データ項目定義（型、桁数、入力制御、必須有無）",
              "データ間の関連（1対多、多対多など）",
              "マスタ・トランザクションの区分整理"
            ]
          },
          {
            "type": "p",
            "text": "データ設計は、後工程の詳細設計や DB 設計に直結するため、漏れや重複があると大きな手戻りになります。業務フローとデータの流れを一致させることが重要です。"
          }
        ]
      },
      {
        "id": "interface-design",
        "title": "外部インターフェース設計（API・バッチ連携）",
        "summary": "他システムとのデータのやり取りを、どの方式・どのタイミングで行うのかを決める工程です。",
        "content": [
          {
            "type": "p",
            "text": "業務システムは単体で動くことは少なく、他システムとの連携が必ず発生します。基本設計では、どのタイミングで、どのデータを、どの方式で連携するのかを設計します。"
          },
          {
            "type": "ul",
            "items": [
              "API方式か、ファイル連携（CSV/固定長）方式か",
              "同期処理か、非同期処理か",
              "連携エラー発生時のリトライ方式",
              "送受信データ項目の仕様（項目名、型、必須有無）",
              "処理タイミング（リアルタイム / 夜間バッチ）"
            ]
          },
          {
            "type": "p",
            "text": "特に日本の大企業ではバッチ処理での連携が多く、夜間に大量データを処理するケースが一般的です。連携方式を誤ると、システム全体の性能問題に直結します。"
          }
        ]
      },
      {
        "id": "architecture-and-nonfunctional",
        "title": "アーキテクチャ設計と非機能要件の具体化",
        "summary": "性能・セキュリティ・運用性などの非機能要件を、システム構成として具体化します。",
        "content": [
          {
            "type": "p",
            "text": "基本設計では、非機能要件をシステム構成に落とし込みます。例えば『レスポンス3秒以内』という要件があれば、キャッシュ利用や分散構成を検討します。"
          },
          {
            "type": "ul",
            "items": [
              "システム構成図（Web・AP・DB の構成）",
              "セキュリティ設計（権限、認証方式、通信暗号化）",
              "パフォーマンス設計（同時接続数、負荷分散方式）",
              "ログ設計（種類、保持期間、出力タイミング）",
              "バックアップ・リカバリ方式",
              "運用監視項目の設計"
            ]
          },
          {
            "type": "p",
            "text": "非機能要件は軽視されがちですが、システム障害や慢性的な遅延など、多くの問題は非機能要件の設計不足によって発生します。"
          }
        ]
      },
      {
        "id": "documents-and-common-mistakes",
        "title": "基本設計書とレビュー・よくある失敗例",
        "summary": "基本設計書はユーザーにとって最も目に見える成果物であり、レビューを通じて品質を高めます。",
        "content": [
          {
            "type": "p",
            "text": "基本設計の成果物は『基本設計書』という形でまとめられます。この文書は、ユーザーと開発チーム双方にとって“共通言語”となり、後工程の詳細設計・開発の土台になります。"
          },
          {
            "type": "ul",
            "items": [
              "画面設計書（画面項目、レイアウト、遷移）",
              "帳票設計書（出力形式、項目、レイアウト）",
              "外部インターフェース設計書（API・バッチ連携）",
              "データ設計書（エンティティ・項目定義）",
              "非機能仕様書（性能・セキュリティ・運用）"
            ]
          },
          {
            "type": "p",
            "text": "よくある失敗例としては、画面だけ作り込んでデータ構造が矛盾している、API の仕様が曖昧で後工程で揉める、想定外の操作が多く抜けているなどが挙げられます。"
          },
          {
            "type": "ul",
            "items": [
              "ユーザー操作の例外パターンを考慮していない",
              "画面とデータ設計の整合性が取れていない",
              "外部システム連携のエラー処理が曖昧",
              "非機能要件が設計に反映されていない"
            ]
          }
        ]
      }
    ]
  },
  {
    "key": "detailed-design",
    "title": "詳細設計",
    "lessons": [
      {
        "id": "what-is-detailed-design",
        "title": "詳細設計とは何か",
        "summary": "基本設計で決めた外部仕様を、プログラム単位で「どう実装するか」まで落とし込む工程です。",
        "content": [
          {
            "type": "p",
            "text": "詳細設計は、基本設計で決めた画面仕様・データ構造・インターフェース仕様をもとに、個々のプログラムやモジュールが『どのような処理手順で動くのか』を具体的に決める工程です。ここで作られた詳細設計書を見れば、プログラマーが迷わずコーディングできる状態が理想です。"
          },
          {
            "type": "p",
            "text": "業務システム開発では、1つの画面やバッチ処理ごとに『プログラム設計書（PG設計書）』を作成し、入力・出力・処理手順・エラー時の挙動などを細かく定義します。詳細設計の質が低いと、実装段階での手戻りやバグが増え、プロジェクト全体のコスト増大につながります。"
          },
          {
            "type": "ul",
            "items": [
              "基本設計＝システム全体の“外側”の設計",
              "詳細設計＝各プログラムの“中身”の設計",
              "実装（コーディング）とテストの橋渡しとなる重要な工程"
            ]
          }
        ]
      },
      {
        "id": "module-and-structure-design",
        "title": "モジュール構成とプログラム構造の設計",
        "summary": "どの機能をどのモジュールに分割し、どのように呼び出し合うかを整理します。",
        "content": [
          {
            "type": "p",
            "text": "詳細設計ではまず、基本設計で定義された機能をどのような単位でプログラムやモジュールに分割するかを決めます。1画面＝1プログラムとする場合もあれば、共通処理を別モジュールとして切り出して再利用することもあります。"
          },
          {
            "type": "ul",
            "items": [
              "画面ごとのコントローラ／サービスクラスの切り分け",
              "共通処理（バリデーション、ログ出力、日付変換など）の共通モジュール化",
              "モジュール間の依存関係（どのクラスがどのクラスを呼び出すか）の整理",
              "レイヤー構造（プレゼンテーション層、ビジネスロジック層、データアクセス層）の定義"
            ]
          },
          {
            "type": "p",
            "text": "レイヤー分割を明確に行うことで、保守性やテストのしやすさが向上します。特に業務システムでは、要件変更に対応しやすい構造を意識することが重要です。"
          }
        ]
      },
      {
        "id": "db-and-data-access-design",
        "title": "テーブル設計とデータアクセス設計",
        "summary": "DBテーブルの構造や、どのSQL・ORマッパーでデータを扱うかを具体化します。",
        "content": [
          {
            "type": "p",
            "text": "基本設計で決めたデータ構造をもとに、詳細設計ではテーブル定義やインデックス、実際に使用するSQL文やORマッパー（ORM）の設計まで踏み込みます。これにより、データの登録・更新・削除・検索がどのように行われるかが明確になります。"
          },
          {
            "type": "ul",
            "items": [
              "テーブル定義書の詳細化（制約、インデックス、デフォルト値など）",
              "主キー・外部キー・ユニーク制約の最終決定",
              "代表的なSQL文の設計（SELECT/INSERT/UPDATE/DELETE 文）",
              "ORマッパーを使う場合のエンティティクラス設計",
              "トランザクション境界の設計（どこまでを1トランザクションとするか）"
            ]
          },
          {
            "type": "p",
            "text": "パフォーマンス要件や排他制御（同時更新の防止）も、この段階で意識しておく必要があります。DB設計の甘さは、後から性能問題として顕在化しやすいポイントです。"
          }
        ]
      },
      {
        "id": "logic-and-flow-design",
        "title": "処理ロジックとフローチャート設計",
        "summary": "入力から出力までの処理手順を、条件分岐やループを含めて細かく設計します。",
        "content": [
          {
            "type": "p",
            "text": "詳細設計の中心となるのが、処理ロジックの設計です。各プログラムについて、『入力を受け取ってから、どの順番でどの処理を行い、最終的にどの出力を返すのか』をフローチャートや疑似コードで表現します。"
          },
          {
            "type": "ul",
            "items": [
              "画面のロード時に行う初期表示用の処理",
              "ボタン押下時のバリデーション → 登録処理 → 結果表示の流れ",
              "バッチ処理の開始条件・ループ処理・終了条件",
              "条件分岐（例：ステータスによって処理を変える）の詳細な記述",
              "疑似コードやシーケンス図を用いた処理手順の明文化"
            ]
          },
          {
            "type": "p",
            "text": "この段階でロジックを十分に詰めておけば、実装時の迷いや仕様解釈のブレを減らすことができます。逆にここが曖昧だと、プログラマーごとに挙動がバラバラになり、テスト工程で多くの不具合が見つかる原因になります。"
          }
        ]
      },
      {
        "id": "validation-and-error-handling",
        "title": "入力チェック・例外処理・エラー設計",
        "summary": "業務システムの品質を左右する、入力チェックとエラー時の挙動を具体的に定義します。",
        "content": [
          {
            "type": "p",
            "text": "業務システムでは、入力値のチェックやエラー時の挙動が非常に重要です。詳細設計では、どの項目にどのような入力制約をかけるか、エラーが発生した場合にユーザーへどのメッセージを表示し、ログにはどの情報を記録するかを具体的に決めます。"
          },
          {
            "type": "ul",
            "items": [
              "必須チェック・桁数チェック・形式チェック（メール形式、日付形式など）",
              "業務ルールに基づくチェック（在庫数の上限・下限、日付の前後関係など）",
              "例外発生時のハンドリング方針（ロールバック、リトライ、エラー画面遷移）",
              "エラーメッセージの文言と表示位置の設計",
              "エラーログの出力内容（時刻、ユーザーID、入力値、スタックトレースの有無）"
            ]
          },
          {
            "type": "p",
            "text": "ユーザーに見せるメッセージは『分かりやすさ』、ログに残す内容は『原因調査のしやすさ』を重視します。これらを設計段階で決めておくことで、運用・保守の負担も大きく変わります。"
          }
        ]
      },
      {
        "id": "test-view-and-artifacts",
        "title": "テスト観点との結びつきと成果物・よくある失敗",
        "summary": "単体テストや結合テストの観点を意識した詳細設計と、典型的な失敗パターンを整理します。",
        "content": [
          {
            "type": "p",
            "text": "詳細設計は、そのまま単体テスト仕様書の元ネタになります。例えば、条件分岐やループが設計書に明確に書かれていれば、その分だけテストケースも作りやすくなります。就活面接でも、『テストを意識した設計』というキーワードはよく出てきます。"
          },
          {
            "type": "ul",
            "items": [
              "各処理パターン（正常系・異常系・境界値）を意識した設計",
              "単体テスト仕様書と詳細設計書の対応関係を意識する",
              "モジュールを小さく分割し、テストしやすい構造にする",
              "ログ出力や例外設計もテスト観点に含める"
            ]
          },
          {
            "type": "p",
            "text": "詳細設計の成果物としては、プログラム設計書（PG設計書）、クラス図、シーケンス図、テーブル定義書の詳細版などがあります。これらは実装フェーズだけでなく、保守フェーズでも参照され続ける重要ドキュメントです。"
          },
          {
            "type": "ul",
            "items": [
              "よくある失敗例：基本設計との差分が管理されておらず、仕様が分からなくなる",
              "処理フローが口頭依存で、設計書に書かれていない部分が多い",
              "テスト観点を意識していないため、テスト仕様書を作るときに再度仕様確認が必要になる",
              "ログ・エラー処理の設計が曖昧で、障害時の原因調査に時間がかかる"
            ]
          }
        ]
      }
    ]
  },
  {
    "key": "implementation",
    "title": "実装",
    "lessons": [
      {
        "id": "what-is-implementation",
        "title": "実装とは何か",
        "summary": "詳細設計書をもとに、実際にコードを書いてプログラムとして形にしていく工程です。",
        "content": [
          {
            "type": "p",
            "text": "実装は、詳細設計で決めた処理手順やデータ構造を、実際のプログラミング言語（Java、C#、Python、Ruby など）を使ってコードとして書き起こす工程です。ここで作られたソースコードが、最終的にシステムとして動く“中身”になります。"
          },
          {
            "type": "p",
            "text": "業務システム開発では、単に動けばよいコードではなく、保守しやすく、バグが少なく、チーム全体で理解しやすいコードを書くことが求められます。そのため、コーディング規約やレビュー、テストといった仕組みとセットで実装が進められます。"
          },
          {
            "type": "ul",
            "items": [
              "詳細設計書 → ソースコード に変換する工程",
              "コーディング規約や命名ルールに従うことが重要",
              "品質とスピードのバランスを取りながら進める必要がある"
            ]
          }
        ]
      },
      {
        "id": "dev-environment-and-standards",
        "title": "開発環境とコーディング規約",
        "summary": "IDE・ビルドツール・バージョン管理・コーディング規約など、実装を支える基盤を整えます。",
        "content": [
          {
            "type": "p",
            "text": "実装を開始する前に、開発環境を統一しておくことが重要です。IDE（Visual Studio Code、IntelliJ、Eclipse など）、ビルドツール（Maven、Gradle、npm など）、バージョン管理ツール（Git）などをチームで揃え、同じ手順でビルド・実行できる状態にします。"
          },
          {
            "type": "p",
            "text": "また、コーディング規約（インデント、命名ルール、コメントの書き方など）を定めることで、誰が書いたコードでも読みやすくし、将来の保守をしやすくします。大企業やSIerでは、独自のコーディング規約やチェックツール（静的解析ツール）が用意されていることも多いです。"
          },
          {
            "type": "ul",
            "items": [
              "IDE・SDK・フレームワークのバージョンをチームで統一する",
              "ビルド・テスト・実行の手順をドキュメント化する",
              "クラス名・メソッド名・変数名の命名ルールを決める",
              "自動整形（formatter）や静的解析ツールを活用する"
            ]
          }
        ]
      },
      {
        "id": "from-design-to-code",
        "title": "詳細設計書からコードへの落とし込み",
        "summary": "プログラム設計書（PG設計書）を読み取り、クラス・メソッド・ロジックとして実装していきます。",
        "content": [
          {
            "type": "p",
            "text": "実装の基本は、詳細設計書に書かれた情報をそのままコードに写経することではなく、『設計の意図を理解したうえで、適切な構造でコードに落とし込む』ことです。1つの画面やバッチ処理ごとに担当が割り振られ、そのプログラム設計書を見ながらクラス・メソッドを実装していきます。"
          },
          {
            "type": "ul",
            "items": [
              "画面設計書 → コントローラ、View、バリデーションロジックとして実装",
              "データアクセス設計 → リポジトリやDAOクラスのメソッドとして実装",
              "フローチャートや疑似コード → if文、ループ、メソッド分割として実装",
              "共通処理はユーティリティクラスや共通モジュールとして切り出す"
            ]
          },
          {
            "type": "p",
            "text": "詳しい仕様が設計書に書かれていない場合や、実装上の工夫が必要な場合には、設計担当者やリーダーに相談しながら進めることが大切です。勝手な判断で仕様を変更すると、結合テスト以降で大きな問題になります。"
          }
        ]
      },
      {
        "id": "version-control-and-collaboration",
        "title": "バージョン管理とチーム開発",
        "summary": "Git を用いたブランチ戦略とレビューを通じて、複数人で安全に開発を進めます。",
        "content": [
          {
            "type": "p",
            "text": "実務のシステム開発では、1人で完結することはほとんどなく、複数人で同じリポジトリを共有しながら開発を進めます。そのため、Git などのバージョン管理ツールを使って、ソースコードの変更履歴を管理しつつ、コンフリクト（競合）を解消しながら開発します。"
          },
          {
            "type": "ul",
            "items": [
              "main／develop／feature ブランチなどの運用ルールを決める",
              "1つのタスクごとに feature ブランチを切って作業する",
              "コミットメッセージには、何を・なぜ変更したかを簡潔に書く",
              "Pull Request（Merge Request）を通じてレビューを受ける"
            ]
          },
          {
            "type": "p",
            "text": "就活でのアピールポイントとして、『個人開発』だけでなく『チーム開発』での Git 利用経験があると評価されやすくなります。レビューを通じてコード品質を高める文化も、現場では非常に重視されています。"
          }
        ]
      },
      {
        "id": "unit-test-and-debug",
        "title": "単体テストとデバッグ",
        "summary": "1つのクラス・メソッド単位で正しく動くかを確認し、不具合を検出・修正します。",
        "content": [
          {
            "type": "p",
            "text": "実装とセットで行われるのが単体テスト（ユニットテスト）です。詳細設計で定義した処理パターン（正常系・異常系・境界値）に基づいてテストケースを作成し、1つのモジュールが仕様通りに動くかどうかを確認します。"
          },
          {
            "type": "ul",
            "items": [
              "JUnit や xUnit 系フレームワークを使った自動テストの作成",
              "モック（Mock）を用いて外部依存を切り離してテストする",
              "ログ出力やステップ実行（デバッガ）で不具合箇所を特定する",
              "単体テスト結果を残し、後続工程への引き継ぎ資料とする"
            ]
          },
          {
            "type": "p",
            "text": "単体テストを疎かにすると、結合テストや総合テストの段階で大量の不具合が発見され、手戻りが発生します。実務の現場では、『テストしやすいコードを書くこと』も実装スキルの一部として評価されます。"
          }
        ]
      },
      {
        "id": "quality-and-common-mistakes",
        "title": "品質を高める工夫と実装でのよくある失敗",
        "summary": "読みやすく保守しやすいコードを書く工夫と、実装工程でありがちな失敗例を整理します。",
        "content": [
          {
            "type": "p",
            "text": "実装工程では、ただ要件を満たすだけでなく、『後から読んでも理解しやすいコード』『仕様変更に強い構造』を意識することが重要です。そのためには、メソッドの分割、コメントの書き方、命名の工夫など、日々の小さな配慮が効いてきます。"
          },
          {
            "type": "ul",
            "items": [
              "1メソッドに処理を詰め込みすぎず、役割ごとに分割する",
              "変数名・メソッド名に“何をしているか”が伝わる名前をつける",
              "魔法の数字（マジックナンバー）を定数として切り出す",
              "レビューで指摘された点をチーム共通の学びとして共有する"
            ]
          },
          {
            "type": "p",
            "text": "よくある失敗例としては、詳細設計と異なる仕様で実装してしまう、例外処理やエラーハンドリングを後回しにする、ログを出力しておらず障害時に原因が追えない、などが挙げられます。"
          },
          {
            "type": "ul",
            "items": [
              "仕様の解釈を自己判断で変えてしまい、テストフェーズで大きな手戻りになる",
              "とりあえず動くコードを書き、リファクタリングをしないままリリースしてしまう",
              "ログやコメントが乏しく、他のメンバーがコードを読んでも意図が分からない",
              "単体テストを十分に行わず、結合テスト以降で多数の不具合が見つかる"
            ]
          },
          {
            "type": "p",
            "text": "就活の場では、『実装で気をつけたいことは何ですか？』という質問に対して、品質・保守性・チーム開発の観点を交えて答えられると、単なる“コーディングができる人”ではなく、“エンジニアとして成長していきそうな人材”として評価されやすくなります。"
          }
        ]
      }
    ]
  },
  {
    "key": "integration-test",
    "title": "結合テスト",
    "lessons": [
      {
        "id": "what-is-integration-test",
        "title": "結合テストとは何か",
        "summary": "単体テストを終えた複数のモジュールを組み合わせ、正しく連携して動作するかを確認する工程です。",
        "content": [
          {
            "type": "p",
            "text": "結合テストは、単体テストで正常に動作することが確認された複数のプログラムやモジュールを組み合わせ、画面・サービス・データアクセス・外部システム連携などが正しく協調して動くかを検証する工程です。"
          },
          {
            "type": "p",
            "text": "単体テストでは検出できなかった“モジュール間の連携不具合”を見つけることが主目的であり、業務システム開発の中でも重要度の高いテストフェーズです。"
          },
          {
            "type": "ul",
            "items": [
              "複数モジュールが正しく連動するかを確認する",
              "画面 → ビジネスロジック → DB の流れを通して検証する",
              "外部システム連携や API 呼び出しの動作確認も含まれる",
              "結合テストの品質が、その後の総合テスト・UAT の安定性を左右する"
            ]
          }
        ]
      },
      {
        "id": "test-scope-and-types",
        "title": "結合テストの範囲と種類",
        "summary": "画面単位・機能単位・API連携単位など、結合テストの対象とする範囲を明確に整理します。",
        "content": [
          {
            "type": "p",
            "text": "結合テストでは、開発規模やシステム構成によってテスト範囲が異なります。画面単位での結合、機能単位での結合、バッチ処理同士の連携確認など、対象を明確に切り分けてテストを実施します。"
          },
          {
            "type": "ul",
            "items": [
              "画面結合（画面 → サービス → DB）",
              "機能結合（注文登録 → 在庫引当 → 請求データ生成 など）",
              "API 結合（社内システムとの REST 連携、外部サービスとの通信）",
              "バッチ処理同士の連携（夜間処理の順序、データ整合性）",
              "イベント駆動の連携（メッセージキューや Pub/Sub 連携）"
            ]
          },
          {
            "type": "p",
            "text": "結合テストの範囲が曖昧だと、結合すべきモジュールが漏れたり、逆に範囲外の部分までテストして工期が遅れる原因になります。"
          }
        ]
      },
      {
        "id": "test-cases-and-design",
        "title": "テストケースの設計と観点",
        "summary": "正常系・異常系・境界値・例外パターンを網羅し、モジュール間の連携不具合を早期に検出します。",
        "content": [
          {
            "type": "p",
            "text": "結合テストでは、単体テストよりも広い観点でテストケースを作成します。特に『連携部分』と『データの流れ』に着目し、正常系だけでなく異常時の挙動も確認することが重要です。"
          },
          {
            "type": "ul",
            "items": [
              "正常系（期待通りに処理が流れるケース）",
              "異常系（連携先がエラーを返す、データ不整合など）",
              "境界値（0件、最大件数、空データなど）",
              "タイミングずれ（APIレスポンス遅延、バッチ重複実行）",
              "整合性確認（DBの更新結果が想定通りか）"
            ]
          },
          {
            "type": "p",
            "text": "結合テストでは、『どのテストで何が確認できるか』という観点整理が非常に重要で、テスト計画の段階から綿密に検討されます。"
          }
        ]
      },
      {
        "id": "test-data-and-environment",
        "title": "テストデータとテスト環境の準備",
        "summary": "本番データを模したテストデータと、実際の構成に近いテスト環境を整えます。",
        "content": [
          {
            "type": "p",
            "text": "結合テストの品質を左右する重要な要素が、テストデータとテスト環境の準備です。実際の業務データに近いテストデータが用意されていないと、結合テストで見つけるべき不具合を検出できません。"
          },
          {
            "type": "ul",
            "items": [
              "マスタデータ（商品、顧客、社員など）の事前登録",
              "想定パターン別に複数種のテストデータを用意",
              "外部システムとの接続先設定（テスト用エンドポイント）",
              "本番に近い構成のテスト環境（AP/DBサーバー構成）",
              "ログ確認がしやすい環境（ログレベルやログ出力設定）"
            ]
          },
          {
            "type": "p",
            "text": "特に外部システム連携では、テスト環境が不十分だと連携部分の不具合が発見できないため、接続テスト（疎通テスト）を事前に行うことが一般的です。"
          }
        ]
      },
      {
        "id": "execution-and-defect-handling",
        "title": "テスト実行と不具合管理",
        "summary": "テスト結果を記録し、不具合が発生した場合は原因を特定し、修正・再テストを行います。",
        "content": [
          {
            "type": "p",
            "text": "結合テストでは、テスト仕様書に沿ってテストを実行し、結果をテスト結果書として残します。不具合が見つかった場合は、ログやトレースを確認し、どのモジュール間で問題が発生しているかを切り分けます。"
          },
          {
            "type": "ul",
            "items": [
              "テスト観点ごとに結果を記録する（成功／失敗）",
              "不具合の原因を特定し、担当者にエスカレーション",
              "修正後は必ず再テスト（リテスト）を実施",
              "影響範囲が広い場合は周辺機能も確認（デグレ確認）",
              "不具合管理表（チケット管理）で進捗を一元管理"
            ]
          },
          {
            "type": "p",
            "text": "結合テストは、単体テストよりも不具合が多く発生するフェーズです。そのため、原因がモジュールなのか、連携なのか、データなのかを切り分ける“調査力”が求められます。"
          }
        ]
      },
      {
        "id": "quality-and-common-mistakes",
        "title": "品質向上のポイントと結合テストのよくある失敗",
        "summary": "結合テストで品質を高めるための観点と、現場で頻発する失敗例を紹介します。",
        "content": [
          {
            "type": "p",
            "text": "結合テストは、システム全体の安定性を確保するための重要工程です。品質を高めるためには、仕様理解・データ設計理解・ログの読み方など、幅広いスキルが必要になります。"
          },
          {
            "type": "ul",
            "items": [
              "連携範囲を正確に把握し、漏れのないテストケースを作成する",
              "異常系・例外系のテストケースを十分に用意する",
              "ログとDBの両方を確認し、データの整合性を判断する",
              "外部システム遅延や応答エラーなど、実務で起きやすいケースを再現する"
            ]
          },
          {
            "type": "p",
            "text": "逆に、結合テストでよくある失敗としては、以下のようなものがあります。"
          },
          {
            "type": "ul",
            "items": [
              "正常系しかテストしておらず、異常系の不具合が総合テストで多発する",
              "テストデータが不十分で、本番特有のケースを再現できない",
              "外部システムの仕様理解不足により連携時にエラーが多発する",
              "ログを残しておらず、原因調査に時間がかかる",
              "結合テストの完了条件が曖昧で、品質判断ができない"
            ]
          },
          {
            "type": "p",
            "text": "就活で質問される場合は、『結合テストでは連携部分の不具合検出が重要』『異常系の網羅が品質の鍵』といった観点を述べると、業務理解の深さがアピールできます。"
          }
        ]
      }
    ]
  },
  {
    "key": "system-test",
    "title": "総合テスト / システムテスト",
    "lessons": [
      {
        "id": "what-is-system-test",
        "title": "総合テスト / システムテストとは何か",
        "summary": "システム全体が“要求された通りに動くか”を、実際の業務フローに沿って確認する最終的なテスト工程です。",
        "content": [
          {
            "type": "p",
            "text": "総合テスト（システムテスト）は、結合テストを終えたシステム全体を実際の業務フローに沿って動かし、要求定義書・基本設計書の内容がすべて満たされているかを確認する工程です。ユーザーが実際に業務で利用する“シナリオ”を再現しながら、システム全体の品質・安定性・性能を検証します。"
          },
          {
            "type": "p",
            "text": "結合テストが“モジュール間の連携確認”であるのに対し、総合テストは“システムの本番挙動を総合的に確認する”工程であり、プロジェクト全体の品質を左右する重要なフェーズと言えます。"
          },
          {
            "type": "ul",
            "items": [
              "要求定義で定めた要件が満たされているか確認する最終工程",
              "業務フローをそのまま再現してテストする",
              "性能・負荷・セキュリティといった非機能要件も検証対象",
              "システム全体としての品質を保証する最も厳しいテスト"
            ]
          }
        ]
      },
      {
        "id": "test-scope-and-types",
        "title": "総合テストの範囲と種類",
        "summary": "機能面・性能面・耐障害性・セキュリティなど、システム全体の動作を幅広く確認します。",
        "content": [
          {
            "type": "p",
            "text": "総合テストでは、単なる機能確認に留まらず、システム稼働に必要な非機能面も含めて幅広い観点を検証します。企業システムでは、性能や負荷、セキュリティ、障害時の動作などが重要になるため、総合テストの範囲は非常に広くなります。"
          },
          {
            "type": "ul",
            "items": [
              "機能テスト：業務フローを通して機能が期待通り動くか",
              "シナリオテスト：受注 → 出荷 → 請求 といった業務全体の流れを再現",
              "性能テスト：レスポンス時間、同時接続数、処理時間の測定",
              "負荷テスト：大量データ処理やアクセス集中時の挙動確認",
              "セキュリティテスト：認証・権限・SQLインジェクションなどの脆弱性確認",
              "障害テスト：サーバーダウンやネットワーク障害時の復旧動作",
              "運用テスト：バックアップ、バッチ処理、ログ出力の確認"
            ]
          },
          {
            "type": "p",
            "text": "特に業務システムでは、画面単位の動作よりも“業務単位で正常に流れるか”が重視されます。"
          }
        ]
      },
      {
        "id": "scenario-and-business-flow",
        "title": "業務シナリオに沿ったテスト設計",
        "summary": "実際の業務フローを再現し、システムが現場の作業手順と一致しているかを確認します。",
        "content": [
          {
            "type": "p",
            "text": "総合テストの特徴は、実際の業務シナリオに沿ってテストする点にあります。単体テストや結合テストでは機能単体を確認しますが、総合テストでは“現場そのままの操作手順”を再現します。"
          },
          {
            "type": "ul",
            "items": [
              "例：受注登録 → 在庫引当 → 出荷処理 → 請求書発行 → データ連携",
              "画面操作とバッチ処理が混在する複雑な業務を再現",
              "実際の担当者（営業、倉庫、経理など）の視点で操作性も確認",
              "マスタデータの整合、トランザクションの流れも重点確認"
            ]
          },
          {
            "type": "p",
            "text": "業務フローに沿ったテストにより、仕様漏れや現場と合わない設計が検出されることがよくあります。設計段階で見落としがちなポイントを洗い出せる重要フェーズです。"
          }
        ]
      },
      {
        "id": "nonfunctional-tests",
        "title": "非機能テスト（性能・負荷・セキュリティ）",
        "summary": "システムの品質を支える“非機能要件”を満たしているかを徹底検証します。",
        "content": [
          {
            "type": "p",
            "text": "総合テストでは、性能・負荷・セキュリティといった非機能要件が本番稼働に耐えられるかどうかを確認します。これらは業務システムでは非常に重要で、性能不足やセキュリティ事故は企業運営に直接影響を与えます。"
          },
          {
            "type": "ul",
            "items": [
              "性能テスト：画面レスポンスが要件を満たすか",
              "同時接続テスト：多数ユーザーアクセス時の安定性",
              "大量データテスト：大量データで処理時間やメモリ使用量を確認",
              "負荷テスト：ピーク時のアクセス集中を再現して動作を確認",
              "セキュリティテスト：認証・権限、脆弱性診断、ログの正しさ",
              "耐障害性テスト：サーバーダウン時の復旧手順やデータ整合性"
            ]
          },
          {
            "type": "p",
            "text": "非機能テストは見落とされがちですが、“本番運用で起こり得る問題”を事前に防ぐもっとも重要な工程のひとつです。"
          }
        ]
      },
      {
        "id": "defect-handling",
        "title": "テスト実行と不具合管理",
        "summary": "テスト結果の記録、原因調査、修正、再テストを繰り返して品質を高めます。",
        "content": [
          {
            "type": "p",
            "text": "総合テストでは、テスト結果を体系的に記録し、不具合が見つかった場合は原因調査 → 修正 → 再テストのサイクルを繰り返します。業務フローが長いため、1つの不具合が複数箇所へ影響することもあります。"
          },
          {
            "type": "ul",
            "items": [
              "テスト結果書への記録（成功／失敗／留意点）",
              "不具合の原因調査（プログラム／データ／連携／環境）",
              "修正内容のレビューとデグレ（副作用）確認",
              "再テストと周辺機能のチェック",
              "不具合管理表やチケットで一元管理"
            ]
          },
          {
            "type": "p",
            "text": "総合テストはシナリオが長く、影響範囲も広いため、不具合管理が特に重要です。再発防止のためのレビューや改善も行われます。"
          }
        ]
      },
      {
        "id": "common-mistakes",
        "title": "品質向上のポイントとよくある失敗例",
        "summary": "総合テストで気をつけるべきポイントと、実務で頻発する典型的不具合を整理します。",
        "content": [
          {
            "type": "p",
            "text": "総合テストは“最後の砦”であり、品質を底上げするラストチャンスです。そのため、観点が不足していたり、細かいケースを見逃すと、本番で重大障害につながる可能性があります。"
          },
          {
            "type": "ul",
            "items": [
              "テスト観点を業務フロー全体で整理する（漏れ防止）",
              "異常系・例外パターンのシナリオを必ず含める",
              "非機能要件（性能・セキュリティ）を軽視しない",
              "テスト環境を本番構成に近づける",
              "ログとDB両方を用いてデータ整合性を確認する"
            ]
          },
          {
            "type": "p",
            "text": "よくある失敗としては、以下のようなものがあります。"
          },
          {
            "type": "ul",
            "items": [
              "業務フローに基づいたシナリオが不足し、現場運用とズレが発生",
              "非機能テストを後回しにし、本番で性能問題が発生",
              "データ整合性の確認不足で、他機能へ影響が出る",
              "テストデータが不十分で、実務パターンが再現されない",
              "外部システム連携を軽視し、本番環境で連携エラーが多発する"
            ]
          },
          {
            "type": "p",
            "text": "就活では、『総合テストは業務フロー全体の再現が重要』『非機能要件の検証が品質の要』と答えると理解度が高く見られます。"
          }
        ]
      }
    ]
  },
  {
    "key": "production-release",
    "title": "本番リリース",
    "lessons": [
      {
        "id": "what-is-production-release",
        "title": "本番リリースとは何か",
        "summary": "開発・テストを終えたシステムを、本番環境へ展開し稼働させる最終工程です。",
        "content": [
          {
            "type": "p",
            "text": "本番リリースとは、開発・テストを終えたシステムを、実際にユーザーが利用する本番環境へ導入し稼働させる工程です。これまでの工程で作り上げた成果物を“現場で使える形”にして公開する、プロジェクトの集大成にあたります。"
          },
          {
            "type": "p",
            "text": "本番リリースは単なるファイルの置き換えではなく、事前準備・手順確認・バックアップ・データ移行・監視体制など、非常に多くの作業を伴います。万一失敗すると業務停止につながるため、慎重かつ確実に進める必要があります。"
          },
          {
            "type": "ul",
            "items": [
              "本番環境へのデプロイ作業",
              "データ移行やマスタ登録",
              "バックアップ取得",
              "リリース後の動作確認（本番確認）",
              "運用体制への引き継ぎ"
            ]
          }
        ]
      },
      {
        "id": "release-planning",
        "title": "リリース計画と手順書の作成",
        "summary": "安全なリリースのために、手順書・スケジュール・担当割り当てを明確に準備します。",
        "content": [
          {
            "type": "p",
            "text": "本番リリースの成功は、事前準備に大きく依存します。特に、リリース手順書の作成は最重要で、細かい手順ミスが重大障害につながるため、誰が実施しても成功するレベルの明確さで記載します。"
          },
          {
            "type": "ul",
            "items": [
              "リリース手順書（デプロイ方法・設定変更・確認項目）の作成",
              "実施担当者と立ち会い者（レビュアー）の割り当て",
              "各作業の開始・終了時間、依存関係の整理",
              "リリースウィンドウ（業務停止時間）の調整",
              "緊急時のロールバック手順（戻し方）を明記"
            ]
          },
          {
            "type": "p",
            "text": "リリース手順書は、SIerでは特に最重要書類として扱われ、レビュー・承認を複数段階で行うことが一般的です。"
          }
        ]
      },
      {
        "id": "backup-and-preparation",
        "title": "バックアップと事前準備",
        "summary": "システム導入前に、本番環境のデータと構成を安全に退避します。",
        "content": [
          {
            "type": "p",
            "text": "本番リリースでは、必ず事前にバックアップを取得します。本番環境のデータや構成情報を保存しておくことで、万一の障害発生時に元の状態へ戻せるようにします。"
          },
          {
            "type": "ul",
            "items": [
              "DB のフルバックアップ（スナップショット含む）",
              "アプリケーションファイルのバックアップ",
              "設定ファイル・環境変数のバックアップ",
              "サーバーの状態を記録（CPU・メモリ・ログなど）",
              "アクセスログや業務データの事前エクスポート"
            ]
          },
          {
            "type": "p",
            "text": "特に金融・物流・医療などのシステムでは、データの欠落は重大な損失につながるため、バックアップは最重要工程とされています。"
          }
        ]
      },
      {
        "id": "deploy-and-data-migration",
        "title": "デプロイとデータ移行",
        "summary": "アプリのデプロイ・設定変更・データ移行を、手順書に沿って正確に実施します。",
        "content": [
          {
            "type": "p",
            "text": "本番リリースの中心となる作業が、デプロイ（システムの本番環境への導入）とデータ移行です。これらは手順の順番や実施時間が非常に重要で、ミスが業務停止につながります。"
          },
          {
            "type": "ul",
            "items": [
              "アプリケーションのデプロイ（サーバーへのリリース）",
              "環境変数・設定ファイルの差し替え",
              "DBマイグレーション（テーブル追加・変更）",
              "大量データ移行（バッチ処理や専用ツールで実施）",
              "外部システムの接続先切替（本番向けエンドポイント）"
            ]
          },
          {
            "type": "p",
            "text": "データ移行は特に失敗リスクが高く、移行前後の件数チェック・データ整合性チェックが必須です。"
          }
        ]
      },
      {
        "id": "post-release-check",
        "title": "本番リリース後の動作確認",
        "summary": "リリース直後の問題を早期に検出するために、重要機能を中心に本番環境で確認します。",
        "content": [
          {
            "type": "p",
            "text": "リリースが完了したら、すぐに本番環境での動作確認を行います。これは“本番確認”と呼ばれ、想定外の不具合を早期に検知するための重要な工程です。"
          },
          {
            "type": "ul",
            "items": [
              "ログイン／ログアウト",
              "メイン画面・重要画面の表示確認",
              "主要業務フロー（受注登録 → 出荷 → 請求など）の試験実行",
              "外部システムとの連携確認",
              "DB更新結果の確認（整合性チェック）",
              "バッチ処理の予定動作（夜間処理など）の確認"
            ]
          },
          {
            "type": "p",
            "text": "本番確認は短時間で行う必要があるため、事前に“本番確認チェックリスト”を準備しておきます。"
          }
        ]
      },
      {
        "id": "handover",
        "title": "運用チームへの引き継ぎ",
        "summary": "本番稼働後の監視・問い合わせ対応を運用チームへ引き継ぎます。",
        "content": [
          {
            "type": "p",
            "text": "本番リリースが完了したら、その後の運用や監視は運用チーム（保守部門）へ引き継がれます。開発チームは仕様や注意点を詳細に共有し、保守チームが安定的に運用できるようサポートします。"
          },
          {
            "type": "ul",
            "items": [
              "運用マニュアルの説明（操作手順・監視項目）",
              "障害時対応フローの説明",
              "問い合わせ窓口・連絡体制の共有",
              "ログの見方や定期バッチの説明",
              "システム構成図の引き渡し"
            ]
          },
          {
            "type": "p",
            "text": "リリース後 1〜2 週間程度は、開発チームが“リリース立ち会い”として即時対応できる体制を取る場合が多いです。"
          }
        ]
      },
      {
        "id": "common-mistakes",
        "title": "品質向上のポイントとよくある失敗例",
        "summary": "本番リリースで失敗しないための要点と、実務で多発するトラブルを整理します。",
        "content": [
          {
            "type": "p",
            "text": "本番リリースは、実務上もっとも緊張感のある工程であり、ミスが企業の業務に直結します。品質を確保するためには、手順書の精度・リハーサル・バックアップの整備が極めて重要です。"
          },
          {
            "type": "ul",
            "items": [
              "手順書を第三者が読んでも実施できるレベルにする",
              "データ移行の件数チェックと整合性確認を徹底する",
              "ロールバック手順を必ず準備しておく",
              "作業者・確認者のダブルチェック体制を整える",
              "夜間リリースの場合は体調管理や作業分担を明確にする"
            ]
          },
          {
            "type": "p",
            "text": "よくある失敗例としては以下の通りです。"
          },
          {
            "type": "ul",
            "items": [
              "手順の抜け漏れによりリリース失敗",
              "設定ファイルの差し替え忘れによる接続エラー",
              "データ移行ミスで業務データが欠落",
              "外部APIの切替忘れにより本番接続できない",
              "バックアップが不十分でロールバックできない"
            ]
          },
          {
            "type": "p",
            "text": "就活では、『本番リリースは準備と手順の正確さが最重要』『ロールバック手順を必ず用意する』と答えると、SIer業務理解が深い学生として評価されます。"
          }
        ]
      }
    ]
  },
  {
    "key": "maintenance-operations",
    "title": "保守運用",
    "lessons": [
      {
        "id": "what-is-maintenance-operation",
        "title": "保守運用とは何か",
        "summary": "システム稼働後の監視・保守・改善を行い、安定した業務運用を支える工程です。",
        "content": [
          {
            "type": "p",
            "text": "保守運用とは、本番リリース後にシステムを安定的に稼働させるための活動全般を指し、監視・障害対応・改善・問い合わせ対応などを継続的に行う工程です。"
          },
          {
            "type": "p",
            "text": "開発フェーズは“作る工程”ですが、保守運用は“安定して動かし続ける工程”であり、企業システムでは最も長期間にわたる継続業務となります。"
          },
          {
            "type": "ul",
            "items": [
              "システム監視（稼働状況・性能・障害検知）",
              "問い合わせ対応（現場ユーザーの疑問・トラブル）",
              "障害調査・復旧対応",
              "軽微な改修や追加開発",
              "定期バッチ・バックアップ・ログ保全"
            ]
          }
        ]
      },
      {
        "id": "monitoring",
        "title": "システム監視",
        "summary": "稼働状態・性能・エラーを常に監視し、異常を早期に検出します。",
        "content": [
          {
            "type": "p",
            "text": "システム監視は、保守運用で最も重要な作業のひとつです。サーバー・アプリケーション・ネットワーク・バッチ処理などの状態をリアルタイムで監視し、異常が検出された際には即時対応します。"
          },
          {
            "type": "ul",
            "items": [
              "サーバーのCPU・メモリ・ディスク監視",
              "アプリケーションのエラーログ監視",
              "DBの負荷・遅延・ロック状況の監視",
              "夜間バッチの成功／失敗監視",
              "外部システムとの通信状況監視",
              "アラート通知（メール・Slackなど）の設定"
            ]
          },
          {
            "type": "p",
            "text": "クラウド環境（AWS、GCP、Azure）では、CloudWatch や Stackdriver などの監視サービスを活用し、詳細なメトリクスを収集します。"
          }
        ]
      },
      {
        "id": "incident-response",
        "title": "障害対応（インシデント対応）",
        "summary": "障害発生時に原因を特定し、迅速に復旧させるための対応プロセスです。",
        "content": [
          {
            "type": "p",
            "text": "本番稼働中の障害は、企業活動に直結する重大問題です。障害対応では、障害発生の検知 → 切り分け → 原因特定 → 復旧対応 → 再発防止という流れで迅速に対応します。"
          },
          {
            "type": "ul",
            "items": [
              "アラート検知（監視ツールからの通知）",
              "一次切り分け（サーバー／DB／アプリ／ネットワークのどこか）",
              "ログ調査やDB調査による原因特定",
              "応急処置（サービス再起動、ロールバックなど）",
              "恒久対応の検討（コード修正・設定変更など）",
              "障害報告書の作成と共有",
              "再発防止策の策定（監視追加・コード改修）"
            ]
          },
          {
            "type": "p",
            "text": "障害対応では、技術力だけでなく“冷静さ”と“正確なコミュニケーション”が重要です。"
          }
        ]
      },
      {
        "id": "customer-support",
        "title": "問い合わせ対応（ユーザーサポート）",
        "summary": "現場ユーザーからの質問や不具合報告に対応し、安定した利用を支援します。",
        "content": [
          {
            "type": "p",
            "text": "保守運用では、現場のユーザー（営業担当・経理担当・倉庫スタッフなど）からの問い合わせ対応が非常に多いです。操作方法の説明から、データ不整合の調査まで、幅広い対応が求められます。"
          },
          {
            "type": "ul",
            "items": [
              "操作方法に関する質問への回答",
              "画面に表示されるエラーの原因調査",
              "データ不整合の調査（現場の入力ミスかシステム不具合か）",
              "ログ・DBを調査して事象を再現",
              "問い合わせ履歴の記録と文書化"
            ]
          },
          {
            "type": "p",
            "text": "現場ユーザーの業務知識が不可欠なため、ITだけでなく“業務理解”が非常に重要になります。"
          }
        ]
      },
      {
        "id": "small-enhancements",
        "title": "軽微な改修・改善",
        "summary": "小規模な機能追加や利便性向上のための改善を、保守チームが継続的に実施します。",
        "content": [
          {
            "type": "p",
            "text": "本番稼働後、利用者からの要望により軽微な改修が発生することは珍しくありません。ボタン位置の変更・集計画面の項目追加・CSV出力の改善など、日常的な改善は保守チームが担当します。"
          },
          {
            "type": "ul",
            "items": [
              "既存画面のUI改善",
              "CSV出力項目の追加・変更",
              "バッチ処理の設定調整",
              "帳票のフォーマット修正",
              "軽微なバグ修正",
              "性能改善のためのSQLチューニング"
            ]
          },
          {
            "type": "p",
            "text": "これらは規模が小さく見えますが、現場の業務効率に大きく影響します。"
          }
        ]
      },
      {
        "id": "routine-operations",
        "title": "定例業務・運用作業",
        "summary": "日次・週次・月次の定例運用作業を確実に実施し、安定稼働を維持します。",
        "content": [
          {
            "type": "p",
            "text": "保守運用では、定期的に行う作業（定例業務）が必ず存在します。これらは手順通り確実に実施され、異常があれば即座に対応する必要があります。"
          },
          {
            "type": "ul",
            "items": [
              "日次バッチ／月次バッチの実行確認",
              "バックアップ取得と格納",
              "ログローテーションと保管",
              "ディスク容量・メモリ使用率の確認",
              "セキュリティパッチ適用計画の策定",
              "定期的な障害訓練や運用手順の見直し"
            ]
          },
          {
            "type": "p",
            "text": "特に夜間バッチの失敗は、翌日の業務に大きく影響するため、最優先で対応されます。"
          }
        ]
      },
      {
        "id": "quality-and-common-mistakes",
        "title": "品質向上のポイントとよくある失敗例",
        "summary": "安定した運用のための注意点と、現場で多発する保守運用トラブルを整理します。",
        "content": [
          {
            "type": "p",
            "text": "保守運用では、障害対応・問い合わせ対応・改善要求が頻繁に発生するため、全体を管理する能力が重要です。また、運用作業は軽視されやすいものの、“企業の根幹を支える重要業務”です。"
          },
          {
            "type": "ul",
            "items": [
              "ログを正しく読み取り、原因を客観的に分析する",
              "業務部門とのコミュニケーションを大切にする",
              "問い合わせ対応履歴を残し、再発防止に役立てる",
              "定例作業を自動化し、ヒューマンエラーを防ぐ",
              "運用手順書を常に最新化する"
            ]
          },
          {
            "type": "p",
            "text": "ありがちな失敗例としては以下があります。"
          },
          {
            "type": "ul",
            "items": [
              "ログを確認せずに憶測で対応してしまう",
              "問い合わせ履歴が残されず、同じ質問が繰り返される",
              "運用手順書の更新漏れにより誤操作が発生",
              "データ不整合の原因調査が不十分で再発",
              "定例バッチの失敗を翌日まで気づかない"
            ]
          },
          {
            "type": "p",
            "text": "就活では、『保守運用は業務理解・ログ分析・現場コミュニケーションが重要』と答えると、深い理解を示すことができます。"
          }
        ]
      }
    ]
  }
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
];


/** ---------- 难度徽章样式 ---------- */
const levelBadge: Record<NonNullable<Lesson["level"]>, string> = {
  basic: "bg-emerald-500/20 text-emerald-600 border border-emerald-500/30 dark:text-emerald-300",
  intermediate: "bg-sky-500/20 text-sky-600 border border-sky-500/30 dark:text-sky-300",
  advanced: "bg-violet-500/20 text-violet-600 border border-violet-500/30 dark:text-violet-300",
};

/** ---------- 滚动联动 ---------- */
function useScrollSpy(ids: string[], offset = 120) {
  const [activeId, setActiveId] = useState<string | null>(null);
  useEffect(() => {
    const handler = () => {
      let current: string | null = null;
      for (const id of ids) {
        const el = document.getElementById(id);
        if (!el) continue;
        const rect = el.getBoundingClientRect();
        if (rect.top <= offset) current = id;
        else break;
      }
      setActiveId(current ?? ids[0] ?? null);
    };
    handler();
    window.addEventListener("scroll", handler, { passive: true });
    return () => window.removeEventListener("scroll", handler);
  }, [ids, offset]);
  return activeId;
}

/** ---------- 页面组件 ---------- */
export default function TsBasicsPage() {
  const [query, setQuery] = useState("");
  const [theme, setTheme] = useState<"light" | "dark">("light");

  // 切换主题
  const toggleTheme = () => {
    setTheme((prev) => (prev === "light" ? "dark" : "light"));
  };

  // 搜索过滤
  const filtered = useMemo(() => {
    const q = query.trim().toLowerCase();
    if (!q) return CURRICULUM;
    return CURRICULUM.map((c) => ({
      ...c,
      lessons: c.lessons.filter(
        (lsn) =>
          lsn.title.toLowerCase().includes(q) ||
          (lsn.summary ?? "").toLowerCase().includes(q) ||
          lsn.content.some((node) => {
            if (node.type === "p") return node.text.toLowerCase().includes(q);
            if (node.type === "code")
              return node.code.toLowerCase().includes(q) || (node.filename ?? "").toLowerCase().includes(q);
            if (node.type === "ul") return node.items.some((t) => t.toLowerCase().includes(q));
            return false;
          })
      ),
    })).filter((c) => c.lessons.length > 0);
  }, [query]);

  // ScrollSpy
  const allIds = useMemo(() => filtered.flatMap((c) => c.lessons.map((l) => l.id)), [filtered]);
  const activeId = useScrollSpy(allIds);

  return (
    <div className={`${theme === "dark" ? "bg-neutral-950 text-neutral-100" : "bg-white text-neutral-900"} min-h-screen transition-colors`}>
      {/* 顶部条 */}
      <header
        className={`sticky top-0 z-40 border-b backdrop-blur ${
          theme === "dark"
            ? "border-white/10 bg-neutral-950/70"
            : "border-neutral-200 bg-white/80"
        }`}
      >
        <div className="max-w-7xl mx-auto px-4 py-3 flex items-center gap-3">
          {/* ✅ 新增：返回首页按钮 */}
          <Link
            href="/"
            className={`flex items-center gap-1 px-2 py-1 rounded-lg border text-sm transition ${
              theme === "dark"
                ? "border-white/20 hover:bg-white/10 text-white"
                : "border-neutral-300 hover:bg-neutral-100 text-neutral-800"
            }`}
          >
            <ChevronRight className="w-4 h-4 -rotate-180" />
            <span>トップページ</span>
          </Link>

          <BookOpen className="w-5 h-5 opacity-80 ml-2" />
          <h1 className="text-lg font-semibold tracking-wide">
            システムエンジニアの仕事流れ
          </h1>

          <button
            onClick={toggleTheme}
            className={`ml-auto flex items-center gap-1 px-2 py-1 rounded-lg border transition ${
              theme === "dark"
                ? "border-white/20 hover:bg-white/10"
                : "border-neutral-300 hover:bg-neutral-100"
            }`}
          >
            {theme === "dark" ? <Sun className="w-4 h-4" /> : <Moon className="w-4 h-4" />}
            <span className="text-sm">{theme === "dark" ? "昼" : "夜"}</span>
          </button>
        </div>
      </header>

      <main className="max-w-7xl mx-auto px-4 py-6 grid grid-cols-12 gap-6">
        {/* ✅ 左侧目录：aside 自身 sticky + overflow，独立滚动 */}
        <aside
          className={`
            col-span-12 lg:col-span-4 xl:col-span-3
            sticky top-[72px]
            max-h-[calc(100vh-72px)]
            overflow-y-auto overscroll-contain
            pr-2 pb-10
          `}
        >
          <label
            className={`flex items-center gap-2 rounded-xl px-3 py-2 border mb-3 ${
              theme === "dark"
                ? "bg-white/5 border-white/10 focus-within:border-white/20"
                : "bg-neutral-100 border-neutral-300 focus-within:border-neutral-400"
            }`}
          >
            <Search className="w-4 h-4 opacity-70" />
            <input
              value={query}
              onChange={(e) => setQuery(e.target.value)}
              placeholder="キーワードを検索…"
              className={`bg-transparent outline-none w-full text-sm ${
                theme === "dark" ? "placeholder:text-neutral-400" : "placeholder:text-neutral-500"
              }`}
            />
          </label>

          <nav className="space-y-5">
            {filtered.map((chapter) => (
              <div key={chapter.key} className="space-y-2">
                <div
                  className={`text-xs uppercase tracking-wider ${
                    theme === "dark" ? "text-neutral-400" : "text-neutral-500"
                  }`}
                >
                  {chapter.title}
                </div>
                <ul className="space-y-1">
                  {chapter.lessons.map((l) => (
                    <li key={l.id}>
                      <a
                        href={`#${l.id}`}
                        className={`group flex items-center gap-2 rounded-lg px-3 py-2 border text-sm transition-all ${
                          activeId === l.id
                            ? theme === "dark"
                              ? "border-white/30 bg-white/10"
                              : "border-neutral-400 bg-neutral-100"
                            : theme === "dark"
                            ? "border-white/10 hover:border-white/20 hover:bg-white/5"
                            : "border-neutral-300 hover:border-neutral-400 hover:bg-neutral-50"
                        }`}
                      >
                        <ChevronRight className="w-4 h-4 opacity-70 group-hover:translate-x-0.5 transition-transform" />
                        <span className="flex-1">{l.title}</span>
                        {l.level && (
                          <span className={`text-[10px] px-2 py-0.5 rounded-full ${levelBadge[l.level]}`}>
                            {l.level}
                          </span>
                        )}
                        {typeof l.estMin === "number" && (
                          <span
                            className={`text-[10px] ${
                              theme === "dark" ? "text-neutral-300/80" : "text-neutral-500"
                            }`}
                          >
                            {l.estMin}m
                          </span>
                        )}
                      </a>
                    </li>
                  ))}
                </ul>
              </div>
            ))}
          </nav>
        </aside>

        {/* 右侧内容 */}
        <section className="col-span-12 lg:col-span-8 xl:col-span-9">
          <article className="space-y-10">
            {filtered.map((chapter) => (
              <div key={chapter.key} className="space-y-8">
                {chapter.lessons.map((l) => (
                  <section key={l.id} id={l.id} className="scroll-mt-24">
                    <header className="mb-3">
                      <h2 className="text-2xl font-semibold">{l.title}</h2>
                      {l.summary && (
                        <p
                          className={`mt-1 ${
                            theme === "dark" ? "text-neutral-300" : "text-neutral-600"
                          }`}
                        >
                          {l.summary}
                        </p>
                      )}
                    </header>

                    <div className="prose max-w-none space-y-4">
                      {l.content.map((node, idx) => {
                        if (node.type === "p") {
                          return <p key={idx}>{node.text}</p>;
                        }

                        if (node.type === "ul") {
                          return (
                            <ul key={idx} className="list-disc pl-5 space-y-1">
                              {node.items.map((it, i) => (
                                <li key={i}>{it}</li>
                              ))}
                            </ul>
                          );
                        }

                        if (node.type === "code") {
                          return (
                            <CodeBlock
                              key={idx}
                              code={node.code}
                              lang={node.lang}
                              filename={node.filename}
                              appearance={theme}  // 跟随主题
                            />
                          );
                        }

                        // ✅ 新增：图片节点渲染（用 next/image）
                        if (node.type === "img") {
                          const width = node.width ?? 1200;
                          const height = node.height ?? 800;
                          return (
                            <figure key={idx} className="my-6">
                              <Image
                                src={node.src}
                                alt={node.alt}
                                width={width}
                                height={height}
                                className="rounded-md border border-neutral-200"
                                priority={false}
                              />
                              {node.caption && (
                                <figcaption className="mt-2 text-sm text-neutral-600">
                                  {node.caption}
                                </figcaption>
                              )}
                            </figure>
                          );
                        }

                        return null;
                      })}
                    </div>

                  </section>
                ))}
              </div>
            ))}
          </article>
        </section>
      </main>
    </div>
  );
}